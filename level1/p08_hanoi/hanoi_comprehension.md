## 汉诺塔

```C
int main(){
    Hanoi(n,'A','B','C');
}

void Hanoi(int n, char a, char b, char c)
{
    if (n == 1)
    {
        Move(n, a, c);
    }
    else
    {
        Hanoi(n - 1, a, c, b);
        Move(n, a, c);
        Hanoi(n - 1, b, a, c);
    }
}
void Move(int n, char a, char b)
{
    count++;
    printf("第%d次移动 Move %d: Move from %c to %c !\n",count,n,a,b);
}
```

1. 第一次传入函数时，ABC与abc的相对顺序是一样的，但到后面会发生改变    
   原因是，函数中的A,B,C分别表示"start"开始，"tmp"临时，"end"目标/目的地，本质上是一个参数，有意义的数
2. 此题相较于斐波那契数列比较难以理解，因为此题中同一个函数用了两次递归
3. 算法思想：      
   **前提：基于N个盘子，思考有N个盘子我该怎么排**     
   * (1)如果只有一个圆盘，那么把它从start->end
   * (2)如果圆盘数量n>1，移动过程分为三步      
        第一步：将start的**n-1个**圆盘移动到tmp上   (步骤中有n说明要递归)   
        第二步：将start上的**一个**圆盘移动到end上       
        第三步：将tmp上的**n-1个**圆盘移动到end上

### 如何准确理解函数运行过程
* 在此处定义最外层的的大函数为X，中间的两次递归函数分别称为X1，X2

递归次数|函数| a | b | c
:-:|:-:|:-:|:-:|:-:
1  |X  |A  |B  |C  
  |X1 |A  |C  |B
  |move|A |   |C
2  |X2 |~~C~~  |~~A~~  |~~B~~
  |X2 |B  |A  |C
  |X1 |B  |C  |A
  |move|B |   |C
3  |X2 |A  |B  |C
  |move|A |   |C

* 上述表格，以X2为界定义了递归次数，同时递归次数也代表了此时要移动的最底下的圆盘，即n号圆盘
* 特别注意上面2次递归时的错误范例，此时要运行的X2语句，是**在大框架X语句的前提下**，所以与X1无关，不要被上面干扰！！      
  * 同时，此处X2的目的虽然是要把tmp中的n-1个盘子全部移动到end上，但是前提是要把上面n-2的盘子移动到新的tmp上。由于原来的start空出来了，所以原来的start变成了tmp，原来的tmp变成了start      
  * 由此看来现在的X2接手了原来X的工作，最终如此递归下去了



​        
